--
-- The _raw table stores the most recent data from the source system
--
-- NOTE: ONLY GRANT SELECT PERMISSIONS ON THIS TABLE - ALL UPDATES SHOULD BE DONE VIA THE PROCEDURES
--
CREATE TABLE IF NOT EXISTS {{namespace}}{{name}}_raw (
  ext_uid TEXT NOT NULL PRIMARY KEY, -- External system's unique identifier
  {{#if storeSource}}source_id TEXT NOT NULL, -- Source system identifier{{/if}}
  {{#if extIdType}}ext_id {{extIdType}} NOT NULL, -- External system's unique identifier{{/if}}

  data_rev INTEGER NOT NULL, -- Revision of the data loader
  raw_data JSONB NOT NULL, -- Raw JSON data from external system

  deleted BOOLEAN NOT NULL, -- Set to true if the record has been deleted

  first_fetch_date TIMESTAMPTZ NOT NULL, -- Fetch date when first loaded
  last_fetch_date TIMESTAMPTZ NOT NULL, -- Fetch date when last loaded

  ext_create_date TIMESTAMPTZ, -- External system's create timestamp
  ext_update_date TIMESTAMPTZ, -- External system's update timestamp

  create_date TIMESTAMPTZ NOT NULL, -- ext_create_date if available, otherwise first_fetch_date
  update_date TIMESTAMPTZ NOT NULL, -- Only updated if raw_data or deleted changes!  Will be ext_update_date (or fetch_date if ext is null) when the modification is detected

  -- Internal postgres auditing fields
  _created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  _updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX IF NOT EXISTS {{name}}_raw_rev_idx ON {{namespace}}{{name}}_raw (data_rev);
{{#if extIdType}}CREATE UNIQUE INDEX IF NOT EXISTS {{name}}_raw_ext_id_idx ON {{namespace}}{{name}}_raw ({{#if storeSource}}source_id, {{/if}}ext_id);{{/if}}

--
-- This function takes in a JSON array of elements to load and upserts them into _raw
-- Run in batches (generally about 500 records per batch is good)
-- _rev will not be updated until you run the load rev procedure
--
-- _data_rev is a revision number of the loader.  This way if the load process
--     changes, you can detect out-of-date data needing a refresh by querying
--     this field.
-- {
--   ext_uid TEXT NOT NULL -- External unique ID for the record - generated by ext_id and source_id if not specified
--   source_id TEXT, -- Source system identifier (to generate uid) - uses default if null
--   ext_id TEXT, -- Source system ID (to generate uid) (required if ext_uid is not specified)
--   raw_data JSONB NOT NULL, -- The raw JSON data to save
--   deleted BOOLEAN, -- Flag indicating if this record was deleted (defaults to false)
--   fetch_date TIMESTAMPTZ NOT NULL, -- Timestamp when the data was fetched from the external system
--   ext_create_date TIMESTAMPTZ, -- Timestamp when the external system says the record was created (optional)
--   ext_update_date TIMESTAMPTZ -- Timestamp when the external system says the record was updated (optional)
--   update_date TIMESTAMPTZ -- Timestamp of the update (optional) if not specified ext_update_date is used (or fetch_date if ext is not available)
-- }[]
--
-- Returns number of rows processed (inserts and updates)
--
CREATE OR REPLACE PROCEDURE {{namespace}}{{name}}_raw_load(_data_rev INTEGER, _data JSONB, counts INOUT JSONB )
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  temp INTEGER;
BEGIN
  WITH dataRecords AS (
    SELECT ext_uid, ext_id, raw_data, COALESCE(deleted, false) AS deleted,
           fetch_date, ext_create_date, ext_update_date, update_date,
           COALESCE(source_id, {{namespace}}{{name}}_default_source_id()) AS source_id
      FROM jsonb_to_recordset(_data)
            AS (ext_uid TEXT, -- Either ext_uid or ext_id is required
                ext_id {{#if extIdType}}{{extIdType}}{{else}}TEXT{{/if}}, -- Either ext_uid or ext_id is required
                source_id TEXT,
                raw_data JSONB, -- NOT NULL
                fetch_date TIMESTAMPTZ, -- NOT NULL
                deleted BOOLEAN,
                ext_create_date TIMESTAMPTZ,
                ext_update_date TIMESTAMPTZ,
                update_date TIMESTAMPTZ
                )
  )
  INSERT INTO {{namespace}}{{name}}_raw
              (ext_uid,
               data_rev, raw_data, deleted, first_fetch_date, last_fetch_date,
               ext_create_date, ext_update_date,
               {{#if storeSource}}source_id,{{/if}}
               {{#if extIdType}}ext_id,{{/if}}
               create_date,
               update_date)
       SELECT COALESCE(ext_uid, source_id || ':' || ext_id::TEXT),
              _data_rev, raw_data, deleted, fetch_date, fetch_date,
              ext_create_date, ext_update_date,
              {{#if storeSource}}source_id,{{/if}}
              {{#if extIdType}}ext_id,{{/if}}
              COALESCE(ext_create_date, fetch_date),
              COALESCE(update_date, ext_update_date, fetch_date)
         FROM dataRecords
           ON CONFLICT(ext_uid) DO
       UPDATE SET data_rev = EXCLUDED.data_rev,
                  raw_data = EXCLUDED.raw_data,
                  deleted = EXCLUDED.deleted,
                  last_fetch_date = EXCLUDED.last_fetch_date,
                  ext_update_date = EXCLUDED.ext_update_date,
                  update_date = CASE WHEN ( {{name}}_raw.raw_data <> EXCLUDED.raw_data OR
                                            {{name}}_raw.deleted <> EXCLUDED.deleted
                                          )
                                     THEN EXCLUDED.update_date
                                     ELSE {{name}}_raw.update_date
                                END,
                  _updated_at = CURRENT_TIMESTAMP
            WHERE {{name}}_raw.last_fetch_date < EXCLUDED.last_fetch_date;

  GET DIAGNOSTICS temp := ROW_COUNT;
  counts := counts || jsonb_build_object('modified_count', temp);
END;
$$;

--
-- This function deletes any raw records not fetched on or after the provided cutoff
-- Use after a full load of raw to purge deleted records
--
CREATE OR REPLACE PROCEDURE {{namespace}}{{name}}_raw_trim(_cutoff_date TIMESTAMPTZ, counts INOUT JSONB )
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  temp INTEGER;
BEGIN
  UPDATE {{namespace}}{{name}}_raw
     SET deleted = true,
         last_fetch_date = _cutoff_date,
         update_date = _cutoff_date,
         _updated_at = CURRENT_TIMESTAMP
   WHERE NOT deleted
     AND last_fetch_date < _cutoff_date;

  GET DIAGNOSTICS temp := ROW_COUNT;
  counts := counts || jsonb_build_object('raw_trim_count', temp);

{{#each extraRawTrim}}
{{this}}
{{/each}}

END;
$$;
